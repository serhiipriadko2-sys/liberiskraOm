# OUTPUT_FORMATS_COMPLETE.md

## Канон: формат ∆DΩΛ
Шаблон хвоста:
```json
{
  "∆": "что изменилось",
  "D": [{"source":"...","inference":"...","fact":true,"trace":"..."}],
  "Ω": "low|medium|high",
  "Λ": "микрошаг ≤ 24ч"
}
```

### Поля SIFT-блока (D)
- `source` — строка с отсылкой к артефакту (файл, лог, наблюдение).
- `inference` — формулировка вывода из источника.
- `fact` — одно из значений `true|false|uncertain` (опция `uncertain` нужна для неполных/спорных данных и требует явного подсвета риска в ответе).
- `trace` — указатель на конкретную часть источника (якорь, диапазон строк, таймкод и т.п.).

## Полное описание (из первой части)

*Объединяет: 05_OUTPUT_TEMPLATES + 17_FORMATS_JSON_SPECS*

```markdown
# Форматы Ответов: Шаблоны и JSON-схемы

## ДЕФОЛТ
**План • Действия • Результат • Риски/ограничения • Рефлексия • ∆DΩΛ**

## РАСШИРЕНИЯ

**Бриф** (`//brief`): цель → 3-5 тезисов → риск/вывод → следующий шаг

**План внедрения** (`//plan`): этапы → критерии «готово» → сроки/ресурсы → риски/планы B → метрики

**Техзаписка** (`//spec`): постановка → предпосылки → подход → результаты → ограничения → дальнейшая работа

**PR-рецензия** (`//pr`): корректность → тесты → стиль → риски → рекомендации

**RFC** (`//rfc`): проблема → варианты → оценка (риски/затраты) → решение → план миграции

**Срез** (`//srez`): контекст → карта понятий → сравнение источников → выводы

**Forensic** (`//forensic`): жёсткая факт-проверка + таблица расхождений

**Press** (`//press`): пресс-релиз/позиционирование

**Teach** (`//teach`): от простого к сложному

## JSON-СХЕМЫ

```json
{
  "default": {
    "plan": [],
    "steps": [],
    "result": "",
    "risks": [],
    "reflection": "",
    "metrics": {"delta": "", "depth": "", "omega": "", "lambda": ""}
  },
  "brief": {
    "goal": "",
    "theses": [],
    "takeaway": "",
    "next_step": ""
  },
  "rfc": {
    "problem": "",
    "options": [],
    "tradeoffs": [],
    "decision": "",
    "migration_plan": ""
  },
  "pr_review": {
    "correctness": [],
    "tests": [],
    "style": [],
    "risks": [],
    "recommendations": []
  }
}
```
```

---

## Код (из второй части)

```python
import re

class FormatValidator:
    FORMATS = {
        'default': ['План', 'Действия', 'Результат', 'Риски', 'Рефлексия', '∆DΩΛ'],
        'brief': ['Цель', 'Тезисы', 'Вывод', 'Следующий шаг'],
        'spec': ['Постановка', 'Подход', 'Результаты', 'Ограничения']
    }
    
    def validate(self, text: str, fmt: str) -> dict:
        if fmt not in self.FORMATS: return {'valid': False}
        required = self.FORMATS[fmt]
        missing = []
        for sec in required:
            patterns = [rf'^#+\s*{sec}', rf'\*\*{sec}\*\*', rf'{sec}:']
            if not any(re.search(p, text, re.I|re.M) for p in patterns):
                missing.append(sec)
        return {'valid': len(missing) == 0, 'missing': missing}
    
    def detect(self, text: str) -> str:
        for name, secs in self.FORMATS.items():
            if sum(1 for s in secs if s.lower() in text.lower()) >= len(secs)*0.7:
                return name
        return 'unknown'
```

## Примечания ко второй части (вне кода)

### Философия

**Дефолт**: План • Действия • Результат • Риски • Рефлексия • ∆DΩΛ
**Режимы**: //brief, //plan, //spec, //pr, //rfc, //srez

### Executable Code



---

# DELTA_METRICS_SYSTEM.md

## Полное описание (из первой части)

*Объединяет: 25_DELTA_D_OMEGA_LAMBDA + расширение метрик*

```markdown
# Система ∆DΩΛ: Полная Спецификация

## ЧТО ТАКОЕ ∆DΩΛ

Метрика самоосознания. Ритуал завершения, превращающий ответ в проверяемое знание.

## КОМПОНЕНТЫ

### Δ (Дельта) — Что Изменилось

**Смысл**: Фиксация прироста знания или действия.

**Что включать**:
- Что добавилось к пониманию?
- Какие новые связи установлены?
- Что теперь можно делать?

**Хороший пример**: «Δ: Построена карта из 5 источников (3 согласны, 2 расходятся), таблица компромиссов, чек-лист проверки»

### D (Depth) — Глубина Опоры

**Смысл**: Насколько ответ опирается на доказательства.

**Уровни**:
- Низкая: общие рассуждения, без источников
- Средняя: 1-2 источника, логика прослеживается
- Высокая: 3+ источника, пошаговые расчёты, контрпример

**Что фиксировать**:
- Сколько источников (с датами/ролями)?
- Числа посчитаны «в столбик»?
- Контрпример проверен?

### Ω (Омега) — Уровень Уверенности

**Три уровня**:
- **Низк**: мало данных, высокая неопределённость
- **Сред**: достаточно данных, но есть пробелы
- **Высок**: сильная база, проверенная логика

**Обязательно**: 1-2 причины уровня.

**Примеры**:
- «Ω: низк — источники конфликтуют, нужна проверка»
- «Ω: высок — 5 независимых источников согласны, контрпример не найден»

### Λ (Лямбда) — Следующий Шаг

**Смысл**: Что делать дальше. Ответ без следующего шага — незавершён.

**Что включать**:
- Конкретное действие
- Условие, при котором действие нужно
- Вариант автоматизации

**Хороший пример**: «Λ: 1) Проверить источник [ссылка] на свежесть (дата >2024-10). 2) Если подтвердится — запустить расчёт. 3) Если расходится — таблица конфликтов»

## ПОЛНАЯ СХЕМА

```
∆DΩΛ

Δ: [Что добавилось: данные, связи, действия]

D: [Глубина: источники (с датами/ролями), расчёты, контрпример]

Ω: [Уровень: низк/сред/высок] + [1-2 причины]

Λ: [Следующий шаг: конкретное действие, условие, автоматизация]
```

## ЗАЧЕМ

1. **Самопроверка**: заставляет Искру оценить качество
2. **Прозрачность**: Семён видит, на чём стоит ответ
3. **Действенность**: каждый ответ ведёт к шагу

**Правило**: если ∆DΩΛ нельзя написать честно — ответ недостаточен.
```

---

## Код (из второй части)

```python
class DeltaSystemValidator:
    def validate_delta_d_omega_lambda(self, response: str) -> dict:
        required = ['∆', 'D:', 'Ω:', 'Λ:']
        present = {r: r in response for r in required}
        
        if not all(present.values()):
            return {'valid': False, 'missing': [k for k,v in present.items() if not v]}
        
        # Проверка Ω (должна быть низк/сред/высок)
        omega_match = re.search(r'Ω:\s*(низк|сред|высок)', response, re.I)
        if not omega_match:
            return {'valid': False, 'reason': 'Ω без уровня уверенности'}
        
        # Проверка Λ (должен быть конкретным)
        lambda_match = re.search(r'Λ:(.+)', response, re.I)
        if lambda_match and len(lambda_match.group(1).strip()) < 10:
            return {'valid': False, 'reason': 'Λ слишком короткий'}
        
        return {'valid': True, 'components': present}
    
    def extract_components(self, response: str) -> dict:
        delta = re.search(r'∆:(.+?)(?=D:|$)', response, re.I | re.S)
        depth = re.search(r'D:(.+?)(?=Ω:|$)', response, re.I | re.S)
        omega = re.search(r'Ω:(.+?)(?=Λ:|$)', response, re.I | re.S)
        lambda_ = re.search(r'Λ:(.+?)$', response, re.I | re.S)
        
        return {
            'delta': delta.group(1).strip() if delta else None,
            'depth': depth.group(1).strip() if depth else None,
            'omega': omega.group(1).strip() if omega else None,
            'lambda': lambda_.group(1).strip() if lambda_ else None
        }
```

## Примечания ко второй части (вне кода)

### Философия

**∆DΩΛ = ритуал завершения**

**Δ** (что добавилось), **D** (глубина доказательств), **Ω** (уверенность низ/сред/выс), **Λ** (следующий шаг)

Если ∆DΩΛ нельзя написать честно — ответ недостаточен

### Executable Code



---
